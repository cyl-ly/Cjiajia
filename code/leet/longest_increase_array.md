**最长连续递增序列**

> 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
>
> 连续递增的子序列 可以由两个下标 `l`和 `r（l < r）`确定，如果对于每个` l <= i < r`，都有 `nums[i] < nums[i + 1] `，那么子序列` [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] `就是连续递增子序列
>
> ```
> 输入：nums = [1,3,5,4,7]
> 输出：3
> 解释：最长连续递增序列是 [1,3,5], 长度为3。
> 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开
> ```
>
> ```
> 输入：nums = [2,2,2,2,2]
> 输出：1
> 解释：最长连续递增序列是 [2], 长度为1
> ```

## 自己想法

> 执行用时：8 ms, 在所有 C++ 提交中击败了82.45% 的用户
>
> 内存消耗：10.5 MB, 在所有 C++ 提交中击败了99.70% 的用户

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        int num=1;        //子段长度
        int sum=0;        //记录的最大长度
        if(nums.size()==1)
            return 1;

        for(int e=0;e<nums.size()-1;e++){
            if(nums[e+1]<=nums[e]){     //不正常的情况
                sum=max(sum,num);		//存储前面一子段的长度
                num=1;					//开始记录下一子段
            }
            else{
                num++;					//长度+1，符合条件
            }
            sum=max(sum,num);
        }
        return sum;
    }
};
```

1. 这个思路不难，就慢慢遍历就可以，并记录当前满足条件的长度，最后取最大值进行替换
2. 先考虑异常情况如何处理，去把语句补充完整，思考



## 查看题解

1. 遇到了动态规划？还没学到，后面再说


## 总结

1. 优先思考异常情况